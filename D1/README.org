# SPDX-FileCopyrightText: 2025 GermÃ¡n Caggianese <german.caggianese@pm.me>
# SPDX-License-Identifier: Apache-2.0

#+title: Advent of Code 2025 - Day 1
* Puzzle [[https://adventofcode.com/2025/day/1][Day 1: Secret Entrance]]
- dial from 00 to 99 (NN), makes a *click* when reaching each number.
  - This means 100 possible values to wrap around.

** Input Structure
- Sequence of *rotations* (1 per line)
  - ~L~ â†’ Rotation to lower numbers
  - ~R~ â†’ Rotation to higher numbers
+ Wrap it with %, as C++ â†’ use [[https://en.wikipedia.org/wiki/Modular_arithmetic][modular arithmetic (Gauss)]] with floored division convention

- ~NN~ â†’ number of rotations.
- You start from 50.

* Solution using C++ STD 20
- Meson is there just because I was learning it right before AoC. You can just ~g++ src/main.cpp -o aoc-2020-d1~ or whatever you feel like doing.
- I actually just used ~org-babbel~ to solve it.

#+begin_src
...
R31
Dial position: 86
R25
Dial position: 11
Clicks: 1129
#+end_src
Correct answer~! ðŸŒŸ+1
-----

+ NOTICE: This only solves ~Part One~ Puzzle, for the whole solution check ~/src/main.cpp~

#+begin_src C++ :includes <iostream> <cmath> <fstream> <string> <string_view> <charconv>

int dial = 50;
int clicker = 0;

template <typename T> T floor_mod(T a, T b) {
    return a - b * std::floor(static_cast<double>(a) / static_cast<double>(b));
}

void fright(int r) { dial = floor_mod((dial + r), 100); }

void fleft(int l) { dial = floor_mod((dial - l), 100); }

void click() {
    if (dial == 0) {
        clicker += 1;
    }
}

void parse_file(std::string_view filepath) {
    std::ifstream file(filepath.data());

    for (std::string line; std::getline(file, line);) {
        if (line.empty())
            continue;

        char direction = line[0];

        int value = 0;
        auto [ptr, ec] =
            std::from_chars(line.data() + 1, line.data() + line.size(), value);

        if (ec == std::errc{}) { // Success
            std::cout << line << '\n';

            if (direction == 'L') {
                fleft(value);
                click();
                std::cout << "Dial position: " << dial << "\n";
            } else if (direction == 'R') {
                fright(value);
                click();
                std::cout << "Dial position: " << dial << "\n";
            }
        }
        if (ec != std::errc{}) { // Fail
            std::cerr << "Parse error on line: " << line << '\n';
            continue;
        }
    }
}

int main(){

    std::cout << "Hey AoC 2025!\n\n";
    parse_file("input_test.txt");
    std::cout << "Clicks: " << clicker << "\n";

    return 0;
}
#+end_src

#+RESULTS:
| Hey     | AoC       | 2025! |
|         |           |       |
| L68     |           |       |
| Dial    | position: |    82 |
| L30     |           |       |
| Dial    | position: |    52 |
| R48     |           |       |
| Dial    | position: |     0 |
| L5      |           |       |
| Dial    | position: |    95 |
| R60     |           |       |
| Dial    | position: |    55 |
| L55     |           |       |
| Dial    | position: |     0 |
| L1      |           |       |
| Dial    | position: |    99 |
| L99     |           |       |
| Dial    | position: |     0 |
| R14     |           |       |
| Dial    | position: |    14 |
| L82     |           |       |
| Dial    | position: |    32 |
| Clicks: | 3         |       |
